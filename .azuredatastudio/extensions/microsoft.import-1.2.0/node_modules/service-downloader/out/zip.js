"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const yauzl_1 = require("yauzl");
const path = require("path");
const _mkdirp = require("mkdirp");
const async_1 = require("./async");
const fs_1 = require("fs");
const util_1 = require("util");
const eventemitter2_1 = require("eventemitter2");
const mkdirp = util_1.promisify(_mkdirp);
class ExtractError extends Error {
    constructor(type, cause) {
        let message = cause.message;
        if (type === 'CorruptZip') {
            message = `Corrupt ZIP: ${message}`;
        }
        super(message);
        this.type = type;
        this.cause = cause;
    }
}
exports.ExtractError = ExtractError;
/**
 * Helper class to handle unzipping the contents of a zip archive into a specified directory.
 *
 * Code adapted from https://github.com/microsoft/vscode/blob/6ffa7d5887e60244169ef9699842ff276216be10/src/vs/base/node/zip.ts
 */
class Unzipper {
    constructor() {
        this.eventEmitter = new eventemitter2_1.EventEmitter2({ wildcard: true });
    }
    extract(zipPath, targetPath) {
        let promise = this.openZip(zipPath, true);
        return promise.then(zipfile => this.extractZip(zipfile, targetPath));
    }
    openZip(zipFile, lazy = false) {
        return new Promise((resolve, reject) => {
            yauzl_1.open(zipFile, lazy ? { lazyEntries: true } : undefined, (error, zipfile) => {
                if (error) {
                    reject(toExtractError(error));
                }
                else {
                    resolve(zipfile);
                }
            });
        });
    }
    extractZip(zipfile, targetPath) {
        let extractedEntriesCount = 0;
        return new Promise((c, e) => {
            const throttler = new async_1.Sequencer();
            const readNextEntry = () => {
                extractedEntriesCount++;
                zipfile.readEntry();
            };
            zipfile.once('error', e);
            zipfile.once('close', () => {
                if (zipfile.entryCount === extractedEntriesCount) {
                    c();
                }
                else {
                    e(new ExtractError('Incomplete', new Error(`Incomplete. Found ${extractedEntriesCount} of ${zipfile.entryCount} entries`)));
                }
            });
            zipfile.readEntry();
            zipfile.on('entry', (entry) => {
                // directory file names end with '/'
                if (/\/$/.test(entry.fileName)) {
                    const targetFileName = path.join(targetPath, entry.fileName);
                    mkdirp(targetFileName).then(() => readNextEntry()).then(undefined, e);
                    return;
                }
                const stream = this.openZipStream(zipfile, entry);
                const mode = modeFromEntry(entry);
                throttler.queue(() => stream.then(readable => this.extractEntry(readable, entry.fileName, mode, targetPath, extractedEntriesCount + 1, zipfile.entryCount).then(() => readNextEntry())))
                    .then(undefined, e);
            });
        });
    }
    extractEntry(stream, fileName, mode, targetPath, entryNumber, totalEntries) {
        const dirName = path.dirname(fileName);
        const targetDirName = path.join(targetPath, dirName);
        if (targetDirName.indexOf(targetPath) !== 0) {
            return Promise.reject(new Error(`Error extracting ${fileName}. Invalid file.`));
        }
        const targetFileName = path.join(targetPath, fileName);
        let istream;
        return Promise.resolve(mkdirp(targetDirName)).then(() => new Promise((c, e) => {
            try {
                istream = fs_1.createWriteStream(targetFileName, { mode });
                istream.once('close', () => {
                    this.eventEmitter.emit("entry_extracted" /* ENTRY_EXTRACTED */, targetFileName, entryNumber, totalEntries);
                    c();
                });
                istream.once('error', e);
                stream.once('error', e);
                stream.pipe(istream);
            }
            catch (error) {
                e(error);
            }
        }));
    }
    openZipStream(zipFile, entry) {
        return new Promise((resolve, reject) => {
            zipFile.openReadStream(entry, (error, stream) => {
                if (error) {
                    reject(toExtractError(error));
                }
                else {
                    resolve(stream);
                }
            });
        });
    }
}
exports.Unzipper = Unzipper;
function toExtractError(err) {
    if (err instanceof ExtractError) {
        return err;
    }
    let type = undefined;
    if (/end of central directory record signature not found/.test(err.message)) {
        type = 'CorruptZip';
    }
    return new ExtractError(type, err);
}
// tslint:disable: no-bitwise
function modeFromEntry(entry) {
    const attr = entry.externalFileAttributes >> 16 || 33188;
    return [448 /* S_IRWXU */, 56 /* S_IRWXG */, 7 /* S_IRWXO */]
        .map(mask => attr & mask)
        .reduce((a, b) => a + b, attr & 61440 /* S_IFMT */);
}
//# sourceMappingURL=zip.js.map